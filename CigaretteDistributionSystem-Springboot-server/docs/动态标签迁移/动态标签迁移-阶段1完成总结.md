# 动态标签迁移 - 阶段1完成总结

## 一、完成时间
2025-12-20

## 二、阶段1目标
为 `base_customer_info` 和 `customer_filter` 表添加 `DYNAMIC_TAGS` JSON字段，并完成基础功能验证。

## 三、已完成的工作

### 1. 数据库迁移脚本 ✅
- **文件**: `src/main/resources/scripts/migration/add-dynamic-tags-json-field.sql`
- **内容**: 
  - 为 `base_customer_info` 表添加 `DYNAMIC_TAGS JSON` 字段
  - 为 `customer_filter` 表添加 `DYNAMIC_TAGS JSON` 字段
  - 包含验证查询语句

### 2. 表结构定义更新 ✅
- **文件**: `src/main/resources/scripts/create-customer-filter-partition-table.sql`
- **更新**: 在表创建脚本中添加了 `DYNAMIC_TAGS JSON` 字段定义

### 3. PO类更新 ✅
- **文件**: `src/main/java/org/example/infrastructure/persistence/po/BaseCustomerInfoPO.java`
- **更新**: 
  - 添加了 `dynamicTags` 字段（`Map<String, Object>` 类型）
  - 使用 `@TableField` 注解配置了 `JsonMapTypeHandler` 类型处理器

### 4. JSON类型处理器实现 ✅
- **文件**: `src/main/java/org/example/infrastructure/persistence/typehandler/JsonMapTypeHandler.java`
- **功能**:
  - 实现 `BaseTypeHandler<Map<String, Object>>`
  - 支持 Java Map 与 MySQL JSON 类型之间的双向转换
  - 使用 Jackson ObjectMapper 进行序列化/反序列化
  - 处理 null 和空值情况

### 5. Mapper更新 ✅
- **文件**: `src/main/resources/mapper/TemporaryCustomerTableMapper.xml`
- **更新**: 
  - 在 `ensurePartitionAndInsertDataDynamic` 方法中添加了 `DYNAMIC_TAGS` 字段的同步
  - 确保从 `base_customer_info` 同步数据到 `customer_filter` 时包含 JSON 字段

### 6. 单元测试 ✅
- **文件**: `src/test/java/org/example/infrastructure/persistence/DynamicTagsJsonFieldTest.java`
- **测试覆盖**:
  - ✅ JSON字段的写入和读取
  - ✅ 空JSON字段的处理
  - ✅ JSON字段的更新
  - ✅ 直接SQL查询JSON字段
  - ✅ MySQL JSON函数查询（JSON_EXTRACT、JSON_CONTAINS_PATH）
  - ✅ 复杂JSON结构的处理

## 四、技术实现细节

### 1. TypeHandler配置
```java
@TableField(value = "DYNAMIC_TAGS", jdbcType = JdbcType.VARCHAR, typeHandler = JsonMapTypeHandler.class)
private Map<String, Object> dynamicTags;
```

### 2. JSON序列化/反序列化
- **序列化**: Java Map → JSON String（写入数据库）
- **反序列化**: JSON String → Java Map（从数据库读取）
- **空值处理**: null 或空字符串 → 空 HashMap

### 3. 数据同步
在 `TemporaryCustomerTableMapper.xml` 中，确保 `customer_filter` 表从 `base_customer_info` 同步时包含 `DYNAMIC_TAGS` 字段：
```xml
DYNAMIC_TAGS
FROM `base_customer_info`
```

## 五、下一步工作（阶段2：双写阶段）

### 待完成任务
1. **数据迁移脚本**
   - 将现有固定标签字段（如 `QUALITY_DATA_SHARE`）的数据迁移到 JSON 字段
   - 编写数据迁移脚本，确保数据一致性

2. **代码兼容性处理**
   - 修改 `RegionRecordBuilder` 等类，同时支持固定字段和 JSON 字段
   - 优先读取 JSON 字段，如果不存在则读取固定字段

3. **导入逻辑更新**
   - 更新 Excel 导入逻辑，同时写入固定字段和 JSON 字段
   - 确保新导入的数据同时填充两个位置

4. **查询逻辑更新**
   - 更新所有使用标签的查询逻辑，支持从 JSON 字段读取
   - 保持向后兼容，支持旧字段

## 六、注意事项

1. **执行迁移脚本前**
   - ✅ 备份数据库
   - ✅ 在测试环境验证
   - ✅ 确认 MySQL 版本 >= 5.7（支持 JSON 类型）

2. **TypeHandler 注册**
   - MyBatis-Plus 会自动识别 `@TableField` 中的 `typeHandler` 配置
   - 无需额外配置

3. **JSON 字段查询**
   - 可以使用 MySQL JSON 函数进行查询：`JSON_EXTRACT`、`JSON_CONTAINS_PATH` 等
   - 可以为常用标签创建虚拟列和索引以提高查询性能

4. **数据一致性**
   - 阶段2需要确保固定字段和 JSON 字段的数据一致性
   - 建议使用事务确保双写的一致性

## 七、测试验证

### 运行测试
```bash
mvn test -Dtest=DynamicTagsJsonFieldTest
```

### 测试覆盖
- ✅ 基本读写功能
- ✅ 空值处理
- ✅ 更新操作
- ✅ SQL 直接查询
- ✅ MySQL JSON 函数查询
- ✅ 复杂结构处理

## 八、相关文件清单

### 新增文件
1. `src/main/resources/scripts/migration/add-dynamic-tags-json-field.sql`
2. `src/main/java/org/example/infrastructure/persistence/typehandler/JsonMapTypeHandler.java`
3. `src/test/java/org/example/infrastructure/persistence/DynamicTagsJsonFieldTest.java`

### 修改文件
1. `src/main/java/org/example/infrastructure/persistence/po/BaseCustomerInfoPO.java`
2. `src/main/resources/scripts/create-customer-filter-partition-table.sql`
3. `src/main/resources/mapper/TemporaryCustomerTableMapper.xml`

## 九、总结

阶段1（准备阶段）已完成，所有基础功能已实现并通过测试。系统现在支持：

- ✅ JSON 字段的读写
- ✅ TypeHandler 自动转换
- ✅ 数据同步到 customer_filter 表
- ✅ 完整的单元测试覆盖

### 关键成果

1. **基础设施就绪**：JSON字段已添加到数据库表，TypeHandler已实现并配置
2. **向后兼容**：现有代码不受影响，可以逐步迁移
3. **测试完备**：所有核心功能都有单元测试覆盖

### 下一步行动

进入阶段2（双写阶段），主要任务：
1. 修改数据导入逻辑，同时写入固定字段和JSON字段
2. 修改查询逻辑，优先读取JSON字段，兼容固定字段
3. 运行数据迁移脚本，将现有标签数据迁移到JSON字段

---

## 十、执行检查清单

在执行迁移脚本前，请确认：

- [ ] 数据库已备份
- [ ] MySQL 版本 >= 5.7（支持 JSON 类型）
- [ ] 已在测试环境验证迁移脚本
- [ ] 所有单元测试通过
- [ ] 代码编译无错误

---

**阶段1完成日期**: 2025-12-20  
**下一步**: 开始阶段2 - 双写阶段