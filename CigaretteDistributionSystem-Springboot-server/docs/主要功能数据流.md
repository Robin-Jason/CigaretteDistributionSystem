## 一、文档目的与阅读指引

本文件从“数据是如何流动的”角度，说明本项目中两条最重要的业务链路：

- 分配方案生成 & 写回（包含 `2025/9/3` 分配写回测试链路）
- 预测编码查询 & 聚合懒加载

目标是让刚接触项目的同学，能够按照“请求 → 控制器 → 应用服务 → 编排器/算法 → 仓储/数据库 → 返回”的顺序，快速定位到每一步对应的代码文件，并理解该步骤大致做了什么。

## 二、名词与缩写约定

在后续的数据流描述中，会频繁出现以下名词/缩写：

| 名词/缩写           | 含义说明                                                                 |
|---------------------|--------------------------------------------------------------------------|
| 批次（Batch）       | 一组按时间分区的预测/分配数据，通常由 `year` + `month` + `weekSeq` 标识 |
| ADV / 预投放量      | 预测要投放的总量（ADV，Advance），是分配算法的目标值                    |
| 区域客户矩阵        | 以区域为行、档位 D30~D1 为列的矩阵，单元格为“客户数量”                   |
| 分配矩阵            | 与区域客户矩阵同维度的矩阵，单元格为“每位客户分配的条数”或类似单位       |
| D30~D1 / 档位       | 代表 30 个价格/等级档位，从高到低（D30 为最高档）                        |
| 组合 / 投放组合     | 投放方式 + 扩展投放方式 + 标签等组合，用于决定策略与算法                 |
| 聚合编码表达式      | 将多条记录按业务规则合并后形成的表达式，如“城区A+城区B(同档结构)”        |
| 主流程 / 主链路     | 从前端操作到最终落库/返回的完整调用链                                   |

> 说明：后续章节会以“**步骤表 + 调用顺序表**”的形式，分别对“分配方案生成 & 写回”和“预测编码 & 聚合懒加载”进行拆解。

---

## 三、分配方案生成 & 写回（含 2025/9/3 测试链路）——整体鸟瞰

本节先从“高空视角”说明一键生成分配方案 & 写回的主流程，下一节再逐类拆解每一步的具体数据流。

### 3.1 高层步骤概览

从“前端点击一键生成分配方案”到“预测表写回分配结果”，可以概括为以下几个阶段：

| 阶段序号 | 阶段名称                 | 关键参与层级/模块                  | 高层说明                                                         |
|----------|--------------------------|-------------------------------------|------------------------------------------------------------------|
| ①        | 接收请求与参数校验       | API (`DistributionCalculateController`) | 接收 `year/month/weekSeq` 等参数，记录访问日志并做基础校验       |
| ②        | 用例级编排               | Application Service (`DistributionCalculateService`) | 作为用例入口，决定对哪些卷烟/区域执行计算，并调度后续步骤         |
| ③        | 策略装配与算法选择准备   | Orchestrator (`DistributionAllocationOrchestrator` + `StrategyOrchestrator`) | 将预投放数据转换为策略上下文（客户矩阵、区域列表、组合信息等）   |
| ④        | 分配算法执行             | Algorithm Engine + Domain Service   | `DistributionAlgorithmEngine` 选择并调用 Domain 算法服务，产出分配矩阵 |
| ⑤        | 分配结果写回             | Application (`DistributionWriteBackService`) + Domain Repository + Infra Mapper | 将分配矩阵转换为持久化对象并写回预测表 / 统计表                    |
| ⑥        | 事件发布与统计监控       | Domain Event + Application Event Handler | 发布“分配生成开始/完成”等事件，由应用层 Handler 做统计/监控     |
| ⑦        | 汇总结果返回前端         | Application DTO + API VO/Converter | 汇总处理结果（成功/失败条数、错误信息等），转换为 VO 并返回给前端 |

### 3.2 与 2025/9/3 分配写回测试的关系

- **测试入口**：`GenerateDistributionPlanIntegrationTest`（位于 `src/test/java/.../service`）  
  - 该测试通过 Application 层服务直接触发与线上“一键生成分配方案”几乎相同的链路，只是入口在测试代码而非 Controller。

- **测试数据批次**：`year=2025, month=9, weekSeq=3`  
  - 测试使用的就是 2025 年 9 月第 3 周的预测数据，验证该批次整体生成分配方案并写回的正确性与误差范围。

- **链路一致性**：
  - 无论是前端调用 `/api/calculate/generate-distribution-plan`，还是集成测试直接调用 `DistributionCalculateService`，  
    进入 Orchestrator → AlgorithmEngine → Domain Service → Repository → WriteBack 的核心链路是相同的；
  - 因此，排查 2025/9/3 批次的线上问题时，可以直接参考该集成测试和本章节的数据流说明。

> 下一步：在“详细版”中，我们会把上述 ①～⑦ 阶段展开到具体类和方法，逐步说明“输入是什么、做了什么、输出给谁”。 

---

## 四、分配方案生成 & 写回——逐层逐类数据流（详细版）

本节按调用顺序，逐步列出关键代码文件和大致行为，帮助你从日志/调用栈快速定位到具体实现。

### 4.1 从 Controller 到 Application Service

| 步骤 | 代码位置                              | 输入数据                               | 本步主要动作                                                                                  | 输出/流向                                   |
|------|---------------------------------------|----------------------------------------|-----------------------------------------------------------------------------------------------|--------------------------------------------|
| 1    | `api/web/controller/DistributionCalculateController.generateDistributionPlan` | HTTP Body：`GenerateDistributionPlanRequestVo`（year/month/weekSeq、urbanRatio、ruralRatio 等） | 记录请求日志；使用 `@Valid` 做基础校验；调用 Converter 进行 VO→DTO 转换                      | DTO：`GenerateDistributionPlanRequestDto`  |
| 2    | `api/web/converter/DistributionCalculateConverter.toDto` | Request VO                            | 将前端字段映射为应用层 DTO 字段（包括批次信息、比例参数等）                                  | `GenerateDistributionPlanRequestDto` 传给 Service |
| 3    | `application/service/calculate/DistributionCalculateServiceImpl.generateDistributionPlan` | Request DTO                           | 作为“一键生成分配方案”的用例入口：根据批次加载需要处理的卷烟/区域，循环调用编排器进行计算，并汇总结果 | 调用 `DistributionAllocationOrchestrator`，最终得到每支卷烟的分配结果集合 |

### 4.2 Application Orchestrator：组装策略请求并调用策略管理器

| 步骤 | 代码位置                              | 输入数据                                         | 本步主要动作                                                                                         | 输出/流向                                           |
|------|---------------------------------------|--------------------------------------------------|------------------------------------------------------------------------------------------------------|----------------------------------------------------|
| 4    | `application/orchestrator/allocation/DistributionAllocationOrchestrator.calculateAllocationMatrix` | 当前卷烟的业务字段：cigCode/cigName/deliveryMethod/deliveryEtype/tag/deliveryArea/ADV/year/month/weekSeq/marketRatios/remark + 原始 ADV 行数据 | 记录“算法分配开始”日志；构造业务语义的 `DistributionStrategyCommand`（填充投放方式、扩展方式、标签、批次、档位范围、附加信息等） | `DistributionStrategyCommand` 传给 `DistributionStrategyManager` |
| 5    | `application/facade/DefaultDistributionStrategyManager.executeDistributionStrategy` | `DistributionStrategyCommand`                  | 作为 Facade 统一入口：在此完成基础校验、默认值处理，以及 Command → `StrategyExecutionRequest` 的转换，然后委托 `StrategyOrchestrator` 执行策略 | 调用 `StrategyOrchestrator.execute`                |
| 6    | `application/orchestrator/strategy/StrategyOrchestrator.execute` | `StrategyExecutionRequest`                      | 基于投放组合/标签等信息，解析出投放策略；准备 `StrategyContext`（构建区域客户矩阵、目标量、扩展参数等）；然后调用 `DistributionAlgorithmEngine.execute` | `StrategyContext` + `StrategyExecutionRequest` 进入算法引擎 |

### 4.3 AlgorithmEngine & Domain Service：算法选择与执行

| 步骤 | 代码位置                              | 输入数据                                         | 本步主要动作                                                                                                          | 输出/流向                                              |
|------|---------------------------------------|--------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|
| 7    | `application/orchestrator/allocation/DistributionAlgorithmEngine.execute` | `StrategyContext`（含 RegionCustomerMatrix、targetAmount、档位范围）+ `StrategyExecutionRequest` | 从 RegionCustomerMatrix 提取区域列表与原始客户矩阵；根据 max/min grade 裁剪矩阵；计算分组比例和区域分组映射；根据区域数、分组/权重情况决定算法类型（SINGLE_LEVEL / COLUMN_WISE / GROUP_SPLITTING）；执行对应的 `run*` 方法 | 得到“紧凑档位区间”的分配矩阵 allocationCompact，并记录 target/actual/error 日志 |
| 8    | `runSingleLevel` / `runColumnWise` / `runGroupSplitting`（内部私有方法） | 区域列表 + 紧凑客户矩阵 + 目标量 +（可选）自定义顺序/分组比例 | 直接调用 Domain 层算法服务：`SingleLevelDistributionService` / `ColumnWiseAdjustmentService` / `GroupSplittingDistributionService`，执行纯领域算法逻辑 | 返回算法输出矩阵；交给引擎做档位反向展开/补齐并封装到 `StrategyExecutionResult` |
| 9    | `domain/service/algorithm/*ServiceImpl` | 区域列表、客户矩阵、目标量、分组信息等          | 执行具体分配算法（粗调 + 微调 + 约束修正等），不关心日志和技术细节，只产出分配矩阵                                  | 分配矩阵返回给 AlgorithmEngine                        |
| 10   | `StrategyExecutionResult`（回到 StrategyOrchestrator） | 分配矩阵 + 客户矩阵 + 目标区域列表              | 封装本次策略执行结果（成功/失败标志、消息、矩阵结果等），返回给 `DistributionAllocationOrchestrator`                 | `AllocationCalculationResult` 构造的输入               |

### 4.4 写回预测表与汇总结果

| 步骤 | 代码位置                              | 输入数据                                         | 本步主要动作                                                                                               | 输出/流向                                             |
|------|---------------------------------------|--------------------------------------------------|------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
| 11   | `application/orchestrator/allocation/DistributionAllocationOrchestrator`（继续） | `StrategyExecutionResult`                       | 将目标区域列表、分配矩阵、客户矩阵封装为 `AllocationCalculationResult`，包含来源信息（例如使用的策略/算法） | 返回给 `DistributionCalculateServiceImpl`            |
| 12   | `application/service/calculate/DistributionCalculateServiceImpl` | 单支或多支卷烟的 `AllocationCalculationResult` 集合 | 对每支卷烟执行写回逻辑：调用 `DistributionWriteBackService`，同时统计成功/失败条数、误差等                   | 写回结果统计信息（DTO）                              |
| 13   | `application/service/calculate/impl/DistributionWriteBackService` | 区域客户矩阵、分配矩阵、批次信息等             | 将分配矩阵与原始预测记录关联起来，转换为持久化对象；通过 Domain Repository 调用 Infrastructure 仓储实现写回预测表 | 预测表（及相关统计表）中的记录被更新/插入             |
| 14   | `domain/repository/*` + `infrastructure/repository/impl/*` + `infrastructure/persistence/mapper/*` | 写回所需的领域对象/PO                          | RepositoryImpl 调用 Mapper 执行 SQL，将新的分配结果落地到数据库                                           | 数据库持久化完成                                     |

### 4.5 结果封装与返回前端 / 测试断言

| 步骤 | 代码位置                              | 输入数据                                         | 本步主要动作                                                                                                   | 输出/流向                                                  |
|------|---------------------------------------|--------------------------------------------------|----------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| 15   | `application/service/calculate/DistributionCalculateServiceImpl` | 写回完成的统计信息 DTO                         | 汇总整体批次的处理结果（总条数、成功/失败数量、错误信息、最大误差等）                                         | `GenerateDistributionPlanResponseDto`                    |
| 16   | `api/web/converter/DistributionCalculateConverter.toVo` | Response DTO                                   | 将 DTO 映射为 `GenerateDistributionPlanResponseVo`，面向前端展示                                               | Response VO                                               |
| 17   | `api/web/controller/DistributionCalculateController.generateDistributionPlan` | Response VO + 结果状态                         | 将 VO 包装为 `ApiResponseVo`，返回 HTTP 200，`success=true/false` 及提示信息                                   | 前端收到一键生成分配方案的结果                           |
| 18   | `GenerateDistributionPlanIntegrationTest`               | 直接调用 `DistributionCalculateService` 或相关方法 | 在测试环境下构造与 2025/9/3 一致的批次参数，执行完整链路；对最大误差、写回条数、关键 SQL 结果进行断言         | 确认分配方案生成 & 写回链路在该批次上的正确性与稳定性     |

---

## 五、预测编码查询——整体鸟瞰

本节描述的是“查询预测分区/价位段预测数据”的主流程，不包含聚合懒加载；聚合懒加载在下一章单独说明。

### 5.1 高层步骤概览

| 阶段序号 | 阶段名称                 | 关键参与层级/模块                                     | 高层说明                                                                 |
|----------|--------------------------|--------------------------------------------------------|--------------------------------------------------------------------------|
| ①        | 接收查询请求             | API (`PredictionQueryController`)                     | 接收按时间分区或价位段的查询请求参数（year/month/weekSeq）              |
| ②        | 查询用例编排             | Application Service (`PredictionQueryService`)        | 作为查询用例入口，调用领域仓储获取原始记录                               |
| ③        | 数据访问与组装           | Domain Repository + Infra RepositoryImpl + Mapper/PO  | 通过 MyBatis 从预测表/价位段预测表加载数据，转换为 Map/List 结构        |
| ④        | 结果转换与封装           | API Converter (`PredictionQueryConverter`)            | 将 Map/List 转为结构化的 Response VO，便于前端展示                       |
| ⑤        | 响应返回                 | API Controller + `ApiResponseVo`                      | 封装为统一响应结构返回前端                                               |

---

## 六、预测编码查询——逐层逐类数据流（详细版）

### 6.1 从 Controller 到 Application Service

| 步骤 | 代码位置                                      | 输入数据                                     | 本步主要动作                                                                                   | 输出/流向                                      |
|------|-----------------------------------------------|----------------------------------------------|------------------------------------------------------------------------------------------------|-----------------------------------------------|
| 1    | `api/web/controller/PredictionQueryController.listByTime` | 查询参数：`year`、`month`、`weekSeq` | 记录查询日志；接收时间分区参数；调用 `PredictionQueryService.listByTime`                     | 调用 Application Service                      |
| 2    | `api/web/controller/PredictionQueryController.listPriceByTime` | 查询参数：`year`、`month`、`weekSeq` | 记录价位段查询日志；调用 `PredictionQueryService.listPriceByTime`                            | 调用 Application Service                      |
| 3    | `application/service/query/PredictionQueryServiceImpl.listByTime` | year/month/weekSeq DTO 参数             | 调用 Domain Repository 获取普通预测分区数据；不关心具体 SQL 与表结构                         | 返回 `List<Map<String,Object>>` 数据列表      |
| 4    | `application/service/query/PredictionQueryServiceImpl.listPriceByTime` | year/month/weekSeq DTO 参数          | 调用 Domain Repository 获取价位段预测数据                                                     | 返回 `List<Map<String,Object>>` 数据列表      |

### 6.2 Domain Repository & Infrastructure：从数据库加载预测数据

| 步骤 | 代码位置                                      | 输入数据                                     | 本步主要动作                                                                                         | 输出/流向                                         |
|------|-----------------------------------------------|----------------------------------------------|------------------------------------------------------------------------------------------------------|--------------------------------------------------|
| 5    | `domain/repository/CigaretteDistributionPredictionRepository` | year/month/weekSeq 等查询条件        | 定义按时间分区查询预测分区数据的接口抽象                                                             | 由 Infra 实现                                   |
| 6    | `domain/repository/CigaretteDistributionPredictionPriceRepository` | year/month/weekSeq 条件           | 定义按时间分区查询价位段预测数据的接口抽象                                                           | 由 Infra 实现                                   |
| 7    | `infrastructure/repository/impl/CigaretteDistributionPredictionRepositoryImpl` | 查询条件                         | 调用 `CigaretteDistributionPredictionMapper` 对应方法（如 `listByTime`），执行 SQL 查询             | 返回 Mapper 查询结果（通常为 List<PO> 或 List<Map>） |
| 8    | `infrastructure/repository/impl/CigaretteDistributionPredictionPriceRepositoryImpl` | 查询条件                     | 调用 `CigaretteDistributionPredictionPriceMapper` 执行价位段预测数据查询                             | 返回 Mapper 查询结果                             |
| 9    | `infrastructure/persistence/mapper/*Mapper.java` + XML | year/month/weekSeq 参数       | 使用 MyBatis 将参数绑定到 SQL，映射结果为 PO 或 Map                                                 | 将原始数据交给 RepositoryImpl                    |

### 6.3 Converter 与响应封装

| 步骤 | 代码位置                                      | 输入数据                                     | 本步主要动作                                                                                             | 输出/流向                                             |
|------|-----------------------------------------------|----------------------------------------------|----------------------------------------------------------------------------------------------------------|------------------------------------------------------|
| 10   | `api/web/converter/PredictionQueryConverter.toVo` | `List<Map<String,Object>>`                 | 根据固定字段顺序（卷烟代码、名称、编码、投放方式、扩展方式、区域、标签、D30~D1、备注等）组装 `PredictionQueryResponseVo` | 返回给 Controller                                    |
| 11   | `api/web/controller/PredictionQueryController.listByTime` / `listPriceByTime` | Response VO                                | 将 VO 包装为 `ApiResponseVo`，填充成功/失败消息，并返回 HTTP 200                                         | 前端收到预测数据或价位段预测数据，用于展示和校验     |

---

## 七、聚合懒加载——整体鸟瞰

本节描述“前端在列表中按需加载某支卷烟的多区域聚合编码表达式”的主流程，即 `/api/prediction/aggregated-encodings` 接口的数据流。

### 7.1 高层步骤概览

| 阶段序号 | 阶段名称                 | 关键参与层级/模块                                                        | 高层说明                                                                 |
|----------|--------------------------|---------------------------------------------------------------------------|--------------------------------------------------------------------------|
| ①        | 接收懒加载查询请求       | API (`PredictionQueryController.aggregatedEncodings`)                    | 前端在行内点击“查看聚合表达式”，传入 year/month/weekSeq/cigCode 等参数  |
| ②        | 应用服务查询与聚合       | Application Service (`AggregatedEncodingQueryService` + Impl)           | 根据批次和卷烟代码，从预测表中按需拉取该卷烟的记录，并按业务规则做聚合   |
| ③        | 数据访问                 | Domain Repository + Infra RepositoryImpl + Mapper                        | 使用专门的查询（如 `findByCigCode`）高效获取该卷烟相关的预测记录         |
| ④        | 业务聚合与表达式生成     | Application Service + Domain 规则/工具                                   | 按组合/区域/档位结构等规则，将多条记录聚合为一组编码表达式字符串         |
| ⑤        | 响应封装与返回           | API Controller + `ApiResponseVo`                                         | 将字符串列表直接封装为统一响应，返回给前端，供懒加载展示使用             |

---

## 八、聚合懒加载——逐层逐类数据流（详细版）

### 8.1 从 Controller 到 Application Service

| 步骤 | 代码位置                                      | 输入数据                                            | 本步主要动作                                                                                         | 输出/流向                                     |
|------|-----------------------------------------------|-----------------------------------------------------|------------------------------------------------------------------------------------------------------|----------------------------------------------|
| 1    | `api/web/controller/PredictionQueryController.aggregatedEncodings` | 查询参数：`year`、`month`、`weekSeq`、`cigCode` | 记录聚合表达式查询日志；接收批次和卷烟代码参数；调用 `AggregatedEncodingQueryService.listAggregatedEncodings` | 调用 Application Service                     |
| 2    | `application/service/encode/AggregatedEncodingQueryServiceImpl.listAggregatedEncodings` | year/month/weekSeq/cigCode                     | 作为懒加载用例入口：调用 `CigaretteDistributionPredictionRepository` 查询指定卷烟在该批次的预测记录；在内存中按业务规则聚合 | 需要聚合的原始记录集合 → 进入聚合逻辑        |

### 8.2 Domain Repository & Infrastructure：按卷烟代码拉取预测记录

| 步骤 | 代码位置                                      | 输入数据                                            | 本步主要动作                                                                                           | 输出/流向                                         |
|------|-----------------------------------------------|-----------------------------------------------------|--------------------------------------------------------------------------------------------------------|--------------------------------------------------|
| 3    | `domain/repository/CigaretteDistributionPredictionRepository` | year/month/weekSeq/cigCode                     | 定义“按批次 + 卷烟代码查询预测记录”的仓储接口（如 `findByCigCode`）                                   | 由 Infra 实现                                   |
| 4    | `infrastructure/repository/impl/CigaretteDistributionPredictionRepositoryImpl` | 查询条件（含 cigCode）                       | 调用 `CigaretteDistributionPredictionMapper.findByCigCode` 等方法，执行针对性的 SQL 查询               | 返回仅包含该卷烟的预测记录列表（PO 或 Map）     |
| 5    | `infrastructure/persistence/mapper/CigaretteDistributionPredictionMapper` + XML | year/month/weekSeq/cigCode 参数             | 定义按卷烟代码过滤的 SQL；只命中相关记录，避免一次性加载整批次所有卷烟                               | 将原始数据交给 RepositoryImpl                    |

### 8.3 业务聚合与编码表达式生成

> 具体实现细节在 Application Service 中，下面是逻辑视角的拆解。

| 步骤 | 代码位置                                      | 输入数据                                            | 本步主要动作                                                                                               | 输出/流向                                         |
|------|-----------------------------------------------|-----------------------------------------------------|------------------------------------------------------------------------------------------------------------|--------------------------------------------------|
| 6    | `AggregatedEncodingQueryServiceImpl` 内部聚合逻辑 | 单支卷烟在该批次下的预测记录列表                 | 按以下规则对记录进行分组与聚合：<br/>- 只聚合同一批次 + 同一卷烟代码的记录；<br/>- 要求投放方式/扩展方式/标签等关键字段一致；<br/>- 仅当 D30~D1 档位结构等价时才可聚合；<br/>- 先按主扩展维度聚合，再在组内按子扩展维度合并 | 得到一组“聚合编码表达式”（字符串）                |
| 7    | 领域规则/工具（如编码规则实现、表达式拼接工具） | 聚合分组后的记录子集                               | 根据业务定义的编码规则，将一组区域/组合信息转换为可读的表达式字符串（例如区域名拼接、条件说明等）         | 表达式字符串列表                                  |

### 8.4 响应封装与返回前端

| 步骤 | 代码位置                                      | 输入数据                                            | 本步主要动作                                                                                 | 输出/流向                              |
|------|-----------------------------------------------|-----------------------------------------------------|----------------------------------------------------------------------------------------------|---------------------------------------|
| 8    | `application/service/encode/AggregatedEncodingQueryServiceImpl.listAggregatedEncodings` | 表达式字符串列表                                  | 直接返回字符串列表给 Controller，作为本用例的最终结果                                       | `List<String>` 聚合编码表达式         |
| 9    | `api/web/controller/PredictionQueryController.aggregatedEncodings` | `List<String>` 表达式列表                        | 将表达式列表封装为 `ApiResponseVo`，填入 success/message/code 等字段，并返回 HTTP 200       | 前端懒加载收到该卷烟的聚合编码表达式 |

---

## 九、图形化总览（文字版时序图）

本节用简化的“文字版时序图”帮助快速建立整体印象。

### 9.1 分配方案生成 & 写回（核心链路）

```text
前端
  │  POST /api/calculate/generate-distribution-plan
  ▼
DistributionCalculateController
  │  VO → DTO
  ▼
DistributionCalculateServiceImpl
  │  遍历卷烟/区域，调用编排器
  ▼
DistributionAllocationOrchestrator
  │  组装 DistributionStrategyCommand
  ▼
DistributionStrategyManager / DefaultDistributionStrategyManager (Facade)
  │
  ▼
StrategyOrchestrator
  │  构建 StrategyContext（客户矩阵、target 等）
  ▼
DistributionAlgorithmEngine
  │  选择算法：SINGLE_LEVEL / COLUMN_WISE / GROUP_SPLITTING
  │  调用 Domain 算法服务
  ▼
Domain Algorithm Services
  │  计算分配矩阵
  ▼
DistributionWriteBackService
  │  调用 RepositoryImpl + Mapper
  ▼
数据库（预测表 / 统计表）
  │
  ▼
Controller 封装响应 → 前端
```

### 9.2 预测编码查询 & 聚合懒加载

```text
前端
  │  GET /api/prediction/list-by-time
  ▼
PredictionQueryController.listByTime
  │
  ▼
PredictionQueryServiceImpl
  │
  ▼
Domain Repository (Prediction)
  │
  ▼
RepositoryImpl + Mapper + SQL
  │
  ▼
PredictionQueryConverter.toVo
  │
  ▼
Controller 封装响应 → 前端（预测数据）

（懒加载聚合表达式）

前端
  │  GET /api/prediction/aggregated-encodings
  ▼
PredictionQueryController.aggregatedEncodings
  │
  ▼
AggregatedEncodingQueryServiceImpl
  │  调用 PredictionRepository.findByCigCode
  ▼
RepositoryImpl + Mapper + SQL
  │  返回该卷烟相关预测记录
  ▼
AggregatedEncodingQueryServiceImpl
  │  按聚合规则生成编码表达式 List<String>
  ▼
Controller 封装响应 → 前端（聚合编码表达式）
```







