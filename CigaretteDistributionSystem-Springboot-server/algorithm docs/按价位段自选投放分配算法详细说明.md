# 按价位段自选投放分配算法详细说明

## 一、算法概述

按价位段自选投放分配算法用于处理**全市默认策略**的价位段卷烟分配问题。该算法通过"SingleLevel初分配 + 价位段截断 + 误差微调"的三阶段策略，确保同一价位段内的卷烟在档位分布上相对集中，避免低档位客户获得高价位卷烟。

**核心思想**：
1. 先对每支卷烟单独执行SingleLevel算法获得初始分配
2. 按价位段分组后，通过截断操作将同组卷烟的分配集中到较高档位
3. 对截断后产生差额的卷烟进行逐档位微调，使实际投放量逼近目标值

---

## 二、数学模型

### 2.1 问题定义

设共有 $N$ 支按价位段自选投放的卷烟，档位数为 $B = 30$（从 D30 到 D1，索引从 0 到 29）。

对于卷烟 $i$（$i = 1, 2, \ldots, N$）：
- 令 $T_i$ 表示卷烟 $i$ 的目标预投放量（ADV）
- 令 $p_i$ 表示卷烟 $i$ 所属的价位段编号
- 令 $w_i$ 表示卷烟 $i$ 的批发价
- 令 $x_{ij}$ 表示分配给卷烟 $i$ 在档位 $j$ 的数量

对于档位 $j$（$j = 0, 1, \ldots, B-1$）：
- 令 $c_j$ 表示全市档位 $j$ 的客户数
- 索引 0 对应 D30（最高档位），索引 29 对应 D1（最低档位）

### 2.2 约束条件

**单调性约束**（每支卷烟内部）：
$$x_{i0} \geq x_{i1} \geq \cdots \geq x_{i,B-1} \quad \forall i \in \{1, \ldots, N\}$$

即每支卷烟的高档位分配值不小于低档位分配值。

**价位段顺序约束**：
- 组间：价位段按编号升序排列
- 组内：同一价位段内的卷烟按批发价降序排列（高价卷烟优先）

### 2.3 目标函数

对于卷烟 $i$，其**实际投放量** $S_i$ 计算公式为：

$$S_i = \sum_{j=0}^{B-1} x_{ij} \cdot c_j$$

**目标**：对每支卷烟 $i$，最小化误差 $|S_i - T_i|$。

---

## 三、算法详细步骤

### 3.1 阶段1：SingleLevel 初分配

#### 3.1.1 算法描述

对每支卷烟 $i$（$i = 1, \ldots, N$）独立执行 SingleLevel 算法，获得初始分配方案 $\mathbf{x}_i^{(0)} = (x_{i0}^{(0)}, x_{i1}^{(0)}, \ldots, x_{i,B-1}^{(0)})$。

#### 3.1.2 具体步骤

1. **输入**：
   - 全市客户数数组 $\mathbf{c} = (c_0, c_1, \ldots, c_{B-1})$（**已应用两周一访上浮处理**）
   - 卷烟 $i$ 的目标预投放量 $T_i$

2. **执行**：
   ```
   对于每支卷烟 i = 1 到 N：
       调用 SingleLevel(c, T_i)
       获得初始分配 x_i^(0)
   ```

3. **输出**：
   - 每支卷烟的初始分配方案 $\mathbf{x}_1^{(0)}, \mathbf{x}_2^{(0)}, \ldots, \mathbf{x}_N^{(0)}$

**注**：
- SingleLevel 算法详见《单区域分配算法（SINGLE_LEVEL）详细说明》
- 每支卷烟根据其备注独立选择使用原始或上浮后的客户数数组

---

### 3.2 阶段2：价位段截断

#### 3.2.1 算法描述

按价位段分组后，对每个组内卷烟数 $> 1$ 的价位段执行截断操作，将低档位的分配清零，使同组卷烟的分配集中到较高档位。

#### 3.2.2 价位段分组

1. **查询价位段信息**：
   
   从 `base_cigarette_price` 表查询每支卷烟的价位段编号 $p_i$ 和批发价 $w_i$。

2. **分组与排序**：
   
   将卷烟按以下规则排序：
   - **组间**：价位段编号 $p_i$ 升序（高价位段在前）
   - **组内**：批发价 $w_i$ 降序（高价卷烟在前）

3. **构建价位段集合**：
   
   对于价位段 $p$，令 $G_p = \{i \mid p_i = p\}$ 表示该价位段内的卷烟集合。

4. **筛选需要截断的价位段**：
   
   只处理 $|G_p| > 1$ 的价位段（单支卷烟的价位段直接使用初分配结果）。

#### 3.2.3 截断点查找

对于价位段 $p$（$|G_p| > 1$），查找截断点 $k_p$：

**定义**：截断点 $k_p$ 是从 LG（低档位）向 HG（高档位）扫描时，首个满足以下条件的档位索引：

$$|\{i \in G_p \mid x_{ij}^{(0)} > 0\}| \geq 2 \quad \text{其中 } j = k_p$$

即：该档位列至少有两支卷烟的分配量 $> 0$。

**扫描顺序**：从 $j = B-1$（D1，最低档位）向 $j = 0$（D30，最高档位）扫描：

```
k_p = -1  # 初始化为未找到
对于 j 从 B-1 到 0：
    统计该列分配量 > 0 的卷烟数量
    如果 count >= 2：
        k_p = j
        退出循环
```

#### 3.2.4 截断操作

**截断规则**：
- **保留区域**：档位 $j \in [0, k_p]$（D30 到 D$(30-k_p)$）
- **清零区域**：档位 $j \in [k_p+1, B-1]$（D$(29-k_p)$ 到 D1）

**截断后的分配**：

$$x_{ij}^{(1)} = \begin{cases}
x_{ij}^{(0)} & \text{if } j \leq k_p \\
0 & \text{if } j > k_p
\end{cases} \quad \forall i \in G_p$$

**截断后的实际投放量**：

$$S_i^{(1)} = \sum_{j=0}^{k_p} x_{ij}^{(1)} \cdot c_j$$

---

### 3.3 阶段3：误差微调

#### 3.3.1 算法描述

对于截断后实际投放量 $S_i^{(1)} < T_i$ 的卷烟，执行从 HG 到截断点的逐档位 +1 微调，使实际投放量逼近目标值。

#### 3.3.2 微调范围

**微调档位范围**：$j \in [0, k_p]$（从 D30 到截断点）

**禁止微调**：$j \in [k_p+1, B-1]$（截断点以下保持为0）

#### 3.3.3 迭代微调过程

对于每支卷烟 $i \in G_p$，执行以下迭代：

**初始化**：
```
当前分配: x_i = x_i^(1)
当前投放量: S = S_i^(1)
```

**迭代过程**（伪代码）：

```python
while True:
    余量 = T_i - S
    
    # 终止条件：余量 < HG客户数
    if 余量 < c_0:
        # 比较不+1和+1两种方案
        误差1 = |T_i - S|
        S_试探 = S + c_0 * (x_{i0} + 1)  # 如果HG+1
        误差2 = |T_i - S_试探|
        
        if 误差2 < 误差1 且 满足单调性约束:
            x_{i0} += 1  # HG+1
        
        break  # 终止微调
    
    # 执行一轮 HG→截断点 填充
    进展 = False
    for j from 0 to k_p:
        if 不满足单调性约束(x_i, j):
            continue
        
        x_{ij} += 1
        S += c_j
        进展 = True
        
        if S > T_i:
            # 超出目标，撤销这次+1
            x_{ij} -= 1
            S -= c_j
            break  # 退出本轮填充
        
        if S == T_i:
            return  # 恰好命中目标
    
    if not 进展:
        break  # 无法继续微调
```

#### 3.3.4 终止条件

微调在以下任一情况下终止：

1. **余量小于HG客户数**：$T_i - S < c_0$
   - 此时比较 HG+1 前后两种方案，选择误差更小者

2. **恰好命中目标**：$S = T_i$

3. **无法继续进展**：某一轮扫描所有档位都无法+1

#### 3.3.5 最终方案选择

当 $T_i - S < c_0$ 时，生成两个候选方案：

**候选方案A**（不对HG+1）：
$$S_A = \sum_{j=0}^{k_p} x_{ij} \cdot c_j$$
$$\text{误差}_A = |S_A - T_i|$$

**候选方案B**（HG+1）：
$$x_{i0}' = x_{i0} + 1$$
$$S_B = \sum_{j=0}^{k_p} x_{ij}' \cdot c_j = S_A + c_0$$
$$\text{误差}_B = |S_B - T_i|$$

**选择规则**：
$$\text{最终方案} = \begin{cases}
\text{候选方案B} & \text{if } \text{误差}_B < \text{误差}_A \text{ 且 } x_{i0}' \leq x_{i1} \\
\text{候选方案A} & \text{otherwise}
\end{cases}$$

---

## 四、算法流程图

```
开始
  ↓
【阶段1：SingleLevel初分配】
  ↓
对每支卷烟执行SingleLevel算法
  ├─ 输入：全市客户数、目标ADV
  └─ 输出：初始分配 x_i^(0)
  ↓
【阶段2：价位段截断】
  ↓
查询价位段信息（base_cigarette_price表）
  ├─ 获取价位段编号、批发价
  └─ 按组间升序、组内批发价降序排列
  ↓
按价位段分组
  └─ 筛选组内卷烟数 > 1 的价位段
  ↓
对每个需要截断的价位段：
  ├─ 从LG向HG扫描，找到截断点 k_p
  │   └─ 条件：该列至少有两支卷烟分配量>0
  ├─ 保留 [0, k_p] 档位的分配
  └─ 清零 [k_p+1, B-1] 档位的分配
  ↓
【阶段3：误差微调】
  ↓
对每支截断后有差额的卷烟：
  ├─ 初始化：当前分配 = 截断后分配
  └─ 迭代微调：
      ├─ while 余量 >= HG客户数：
      │   ├─ 执行一轮 HG→截断点 逐档位+1
      │   ├─ 如果超出目标，撤销最后一次+1
      │   └─ 继续下一轮
      └─ 终止时：
          ├─ 比较 HG+1 前后两种方案
          └─ 选择误差更小且满足单调性的方案
  ↓
返回最终分配结果
  ↓
结束
```

---

## 五、关键实现细节

### 5.1 截断点查找的正确性

**定理**：从LG向HG扫描找到的首个"至少有两支卷烟分配量>0"的档位，能够最大程度保留高档位分配。

**证明思路**：
- 截断点越靠近HG（索引越小），保留的档位越多
- 从LG向HG扫描确保找到最靠近HG的满足条件的档位
- 该档位之上（包括该档位）的分配得以保留

### 5.2 为什么截断点本身不清零

**原因**：截断点是首个"有两支卷烟分配量>0"的档位，说明该档位是有效分配区域的边界。清零截断点会导致：
1. 丢失过多分配量，增加微调难度
2. 可能导致某些卷烟的分配全部为0（异常情况）

### 5.3 微调范围限制

**为什么只在 [0, k_p] 范围微调**：

1. **保持截断效果**：如果允许在 $[k_p+1, B-1]$ 微调，截断操作将失去意义
2. **高档位优先原则**：价位段分配强调高档位客户优先获得高价位卷烟
3. **计算效率**：限制微调范围可减少迭代次数

### 5.4 撤销策略

**撤销最后一次导致超出的+1**：

在每轮 HG→截断点 扫描中，一旦发现某次+1导致 $S > T_i$，立即撤销该次+1并退出本轮扫描，开始新一轮。

**实现**：
```python
if S > T_i:
    x[lastGrade] -= 1  # 撤销最后一次+1
    S -= c[lastGrade]
    break  # 退出本轮，开始下一轮
```

### 5.5 全0检测与恢复

**异常情况**：某支卷烟经过截断和微调后，所有档位分配量都为0。

**处理策略**：
1. **检测**：遍历所有档位，检查是否全部为0
2. **恢复**：使用截断前保存的初始分配
3. **收集异常**：收集所有全0异常信息，**不中断其他价位段处理**
4. **统一抛出**：所有价位段处理完成后，统一抛出 `IllegalStateException` 给前端

**异常信息格式**（多支卷烟）：
```
价位段截断异常（共N支卷烟）：
卷烟【卷烟名称1(卷烟代码1)】在价位段XXX经过截断和微调后分配结果全0，已恢复初分配。时间：YYYY-MM-WW
卷烟【卷烟名称2(卷烟代码2)】在价位段YYY经过截断和微调后分配结果全0，已恢复初分配。时间：YYYY-MM-WW
...
```

**代码示例**：
```java
// 1. 收集所有全0异常信息
List<String> zeroAllocationErrors = new ArrayList<>();

for (Map.Entry<Integer, List<Map<String, Object>>> entry : bandsNeedingTruncation.entrySet()) {
    Integer band = entry.getKey();
    List<Map<String, Object>> group = entry.getValue();
    
    // ... 截断和微调逻辑 ...
    
    // 检测全0并收集异常信息（不立即抛出）
    checkZeroAllocation(group, band, preTruncationGrades, year, month, weekSeq, zeroAllocationErrors);
}

// 2. 所有价位段处理完成后，统一抛出异常
if (!zeroAllocationErrors.isEmpty()) {
    String errorMessage = String.join("\n", zeroAllocationErrors);
    throw new IllegalStateException("价位段截断异常（共" + zeroAllocationErrors.size() + "支卷烟）：\n" + errorMessage);
}
```

**设计原则**：
- **不中断其他价位段**：某个价位段的全0异常不应该影响其他价位段的正常分配
- **全局视角**：收集所有异常信息后统一报告，方便前端一次性展示所有问题
- **数据完整性**：即使有异常，也会完成所有可能的分配并恢复异常数据

---

## 六、算法复杂度分析

### 6.1 时间复杂度

设：
- $N$：卷烟总数
- $B$：档位数（通常为30）
- $P$：价位段数量
- $n_p$：价位段 $p$ 内的卷烟数

**阶段1（SingleLevel初分配）**：
$$O(N \times B) = O(30N)$$

**阶段2（价位段截断）**：
- 分组：$O(N)$
- 截断点查找：$O(\sum_{p=1}^{P} n_p \times B) = O(N \times B) = O(30N)$
- 截断操作：$O(\sum_{p=1}^{P} n_p \times B) = O(30N)$

**阶段3（误差微调）**：
- 单支卷烟微调：$O(B \times I)$，其中 $I$ 为迭代次数（通常为1-5）
- 所有卷烟：$O(N \times B \times I) = O(30N \times I)$

**总时间复杂度**：
$$O(N \times B \times I) = O(N)$$

线性时间复杂度（$B$ 和 $I$ 为常数）。

### 6.2 空间复杂度

**存储需求**：
- 每支卷烟的分配数组：$O(N \times B)$
- 截断前备份：$O(N \times B)$
- 价位段分组：$O(N)$

**总空间复杂度**：
$$O(N \times B) = O(30N) = O(N)$$

线性空间复杂度。

---

## 七、算法特点

### 7.1 优点

1. **高档位集中**：截断操作确保同价位段卷烟集中在较高档位分配
2. **误差最小化**：微调阶段逐步逼近目标值，确保分配精确
3. **计算高效**：线性时间复杂度，适合实时计算
4. **鲁棒性强**：全0检测与恢复机制，异常情况会及时通知前端

### 7.2 适用场景

- **全市默认策略**：按价位段自选投放的卷烟分配
- **价位段分组**：需要按价位段分组处理的场景
- **高档位优先**：强调高档位客户优先获得高价位卷烟

### 7.3 与SingleLevel算法的区别

| 特性 | SingleLevel算法 | 按价位段算法 |
|------|----------------|-------------|
| **输入** | 单支卷烟 | 多支卷烟（按价位段分组） |
| **分配范围** | 全部30个档位 | 截断后的高档位区域 |
| **微调策略** | 多候选方案比较 | 迭代填充 + 最终方案选择 |
| **约束** | 单调性约束 | 单调性约束 + 截断约束 |
| **适用场景** | 标准分配 | 价位段自选投放 |

---

## 八、示例

### 8.1 输入数据

**卷烟信息**：

| 卷烟代码 | 卷烟名称 | ADV | 价位段 | 批发价 |
|---------|---------|-----|--------|--------|
| 35300088 | 七匹狼(银中支) | 445 | 100 | 70 |
| 44020074 | 双喜(勿忘我) | 831 | 100 | 65 |
| 53010048 | 云烟(软大重九) | 938 | 200 | 100 |

**全市客户数**（部分）：

| 档位 | 客户数 |
|------|--------|
| D30 | 149 |
| D29 | 150 |
| D28 | 299 |
| ... | ... |

### 8.2 执行过程

#### **阶段1：SingleLevel初分配**

**七匹狼(银中支)**：
- 粗调结果：D30=1, D29=1, D28=1，实际=598
- 撤销D28：D30=1, D29=1，实际=299
- 微调后：D30=2, D29=1，实际=448
- 误差：|448-445|=3

**双喜(勿忘我)**：
- 初分配结果：D30=3, D29=1, D28=1，实际=834
- 误差：|834-831|=3

#### **阶段2：价位段截断**

**价位段100**（包含七匹狼、双喜）：

**初分配矩阵**：
```
         D30  D29  D28  D27  ...
七匹狼    2    1    0    0   ...
双喜      3    1    1    0   ...
```

**截断点查找**：
- 从D1→D30扫描
- D28列：七匹狼=0，双喜=1，count=1 < 2，继续
- D29列：七匹狼=1，双喜=1，count=2 ≥ 2，找到截断点 k=1（D29）

**截断后矩阵**：
```
         D30  D29  D28  D27  ...
七匹狼    2    1    0    0   ...  (D28已经是0，无变化)
双喜      3    1    0    0   ...  (D28清零)
```

**截断后实际投放量**：
- 七匹狼：2×149 + 1×150 = 448（无变化）
- 双喜：3×149 + 1×150 = 597（减少了299）

#### **阶段3：误差微调**

**七匹狼**：实际=448，目标=445，已超出，无需微调

**双喜**：实际=597，目标=831，差额=234，需要微调

**微调过程**（简化）：
```
初始：D30=3, D29=1, 实际=597, 余量=234

迭代1：
  D30+1 → D30=4, 实际=746
  D29+1 → D29=2, 实际=896 > 831 (超出)
  撤销D29 → D29=1, 实际=746
  余量=85 < HG客户数(149)，进入终止判断

终止判断：
  方案A（不+1）：实际=746，误差=|746-831|=85
  方案B（D30+1）：实际=746+149=895，误差=|895-831|=64
  选择方案B：D30=5, D29=1
```

**最终结果**：D30=5, D29=1，实际=895，误差=64

### 8.3 输出结果

| 卷烟名称 | 价位段 | D30 | D29 | D28 | 实际投放 | 目标ADV | 误差 |
|---------|--------|-----|-----|-----|----------|---------|------|
| 七匹狼(银中支) | 100 | 2 | 1 | 0 | 448 | 445 | 3 |
| 双喜(勿忘我) | 100 | 5 | 1 | 0 | 895 | 831 | 64 |
| 云烟(软大重九) | 200 | 1 | 1 | 1 | 598 | 938 | 340 |

**说明**：
- 价位段100内的卷烟（七匹狼、双喜）经过截断后，分配集中在D30-D29
- 价位段200单支卷烟，直接使用初分配结果

---

## 九、注意事项

1. **价位段数据完整性**：必须确保所有按价位段自选投放的卷烟在 `base_cigarette_price` 表中有价位段信息

2. **单支卷烟价位段**：组内只有一支卷烟的价位段不需要截断，直接使用初分配结果

3. **截断点未找到**：如果某个价位段找不到满足条件的截断点，跳过截断操作

4. **微调范围限制**：微调只能在 [0, k_p] 范围内进行，不能在截断点以下的档位+1

5. **全0异常处理**：如果卷烟截断后全0，系统会恢复初分配并抛出异常给前端

6. **单调性约束**：微调过程中必须严格满足单调性约束

7. **两周一访上浮支持**：系统支持"两周一访上浮100%"功能
   - **单支卷烟级别**：根据每支卷烟的备注（BZ字段）独立判断是否上浮
   - **准备两份客户数**：原始客户数 + 上浮后客户数（如果本次有卷烟需要上浮）
   - **初分配阶段**：有备注的卷烟使用上浮后客户数进行 SingleLevel 分配
   - **微调阶段**：有备注的卷烟使用上浮后客户数进行误差补偿
   - **条件**：备注包含"两周一访上浮100%"且 `customer_filter` 表中存在单周/双周客户

---

## 十、参考资料

1. 《单区域分配算法（SINGLE_LEVEL）详细说明》
2. 《多区域无权重分配算法（COLUMN_WISE）详细说明》
3. 《价位段规则配置说明》（price-band-rules.yml）
4. 《两周一访上浮业务规则说明》

---

**文档版本**：v1.0  
**最后更新**：2025-12-22  
**作者**：Robin

