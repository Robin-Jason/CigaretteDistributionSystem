## 一、总体架构概览（Architecture Overview）

本项目采用 **DDD 分层架构 + Spring Boot 技术栈** 的整体设计，将业务逻辑与技术细节分离，  
并通过清晰的“自上而下依赖、向内依赖”规则保证高内聚、低耦合，便于后续扩展与重构。

### 1.1 分层结构总览

从外到内，大致分为五层（不含测试层）：

| 层级              | 主要包路径前缀                 | 角色定位                                             |
|-------------------|--------------------------------|------------------------------------------------------|
| API 层            | `org.example.api.web`          | 对外 HTTP 接口入口，面向前端/外部系统，提供 RESTful API 接口 |
| Application 层    | `org.example.application`      | 用例编排与应用服务层，组织完整业务流程，协调领域服务与基础设施 |
| Domain 层         | `org.example.domain`           | 领域模型与业务规则层，承载核心业务逻辑，定义算法与规则 |
| Infrastructure 层 | `org.example.infrastructure`   | 技术实现层：数据库访问、配置加载、监控、历史算法实现等 |
| Shared 层         | `org.example.shared`           | 跨层共享的基础能力：常量定义、工具类、异常处理、辅助服务等 |

> 说明：测试代码位于 `src/test/java/org/example`，用于覆盖接口、应用服务与领域服务的关键场景，不参与业务分层。

### 1.2 依赖方向（谁可以依赖谁）

整体遵循“**内核优先、依赖向内**”的原则，依赖方向如下：

```text
API  →  Application  →  Domain
                 ↘
                  Infrastructure

（所有业务层都可以依赖 Shared，用于复用工具和常量）
```

- **API 层**：只依赖 Application 层和 Shared 层，不直接依赖 Domain/Infrastructure。
- **Application 层**：依赖 Domain 层、Infrastructure 层（通过 Repository 接口/事件等）以及 Shared 层。
- **Domain 层**：只依赖 Shared 层，不依赖 API/Application/Infrastructure，保证业务逻辑的纯粹性与可测试性。
- **Infrastructure 层**：可以依赖 Domain 的抽象（例如 Repository 接口），为其提供技术实现，不反向依赖上层。
- **Shared 层**：不依赖其他业务层，是所有层都可以安全复用的“工具/基础设施”模块。

### 1.3 关键技术组件

项目在架构上大量使用以下技术组件：

- **Spring Boot / Spring MVC**：提供应用启动、配置管理和 REST 接口支持。
- **Spring Event**：用于在 Domain/Application 层之间通过事件进行解耦（如导入完成、分配生成完成等事件）。
- **MyBatis**：负责持久化层的 SQL 映射与数据库访问，由 `infrastructure.persistence.mapper` 与 `*.xml` 配合完成。
- **MyBatis-Plus**：简化 MyBatis 开发，提供基础 CRUD 能力。
- **MapStruct**：用于对象映射转换，减少手动编写转换代码。
- **Lombok**：简化实体、DTO、VO 等类的样板代码（如 getter/setter、日志对象等）。
- **Apache POI**：用于 Excel 文件的解析与生成，支持导入导出功能。
- **JUnit**：用于编写单元测试与集成测试，验证分配算法、懒加载聚合、分配写回等主链路。
- **Micrometer / MeterRegistry**（通过配置）：用于监控关键指标，为线上稳定性提供支持。

在后续小节中，将分别从“分层架构说明”“内部依赖关系表”“关键组件依赖关系表”“外部依赖说明”“架构约束与最佳实践”几个方面进一步展开。

---

## 二、分层架构说明（Layered Architecture）

本节从“架构职责和依赖边界”的角度，分别说明各层应该做什么、不应该做什么，方便新同学判断代码应放在哪一层。

### 2.1 API 层（org.example.api.web）

- **职责**：对外暴露 HTTP 接口，是前端/外部系统访问本系统的唯一入口。
- **包含内容**：
  - `controller`：控制器类，定义 URL、HTTP 方法、参数与返回体。当前包含5个Controller:
    - `DistributionCalculateController`: 分配计算接口（生成分配方案、计算投放量、策略调整、获取可用区域）
    - `ExcelImportController`: 数据导入接口（客户基础信息表、卷烟投放基础信息表）
    - `PredictionController`: 预测数据查询与维护接口（查询、新增、删除、修改、聚合编码懒加载）
    - `DeliveryCombinationRegionController`: 统计查询接口（投放组合与区域映射）
    - `PriceBandOrderLimitController`: 统计查询接口（价位段订购量上限）
  - `vo.request` / `vo.response`：面向前端的请求/响应模型。
  - `converter`：VO 与 Application 层 DTO 之间的转换。
- **可以做的事**：
  - 解析请求参数、做基础校验（使用 `@Valid`、`@NotNull` 等注解）。
  - 调用 Application 层服务，记录必要的访问日志。
  - 使用统一响应包装类 `ApiResponseVo<T>` 构造返回结果。
  - 捕获异常并转换为用户友好的错误消息。
- **不应该做的事**：
  - 直接访问数据库或调用 Mapper。
  - 实现复杂的业务规则或算法。
  - 操作领域实体/值对象的复杂状态变更。

### 2.2 Application 层（org.example.application）

- **职责**：承载"用例级别"的业务流程编排，是"一个按钮/一个接口"背后完整业务流程的实现者。
- **包含内容**：
  - `service/*`：按子域组织的应用服务接口与实现，包含以下子包：
    - `calculate`: 分配计算服务（统一分配服务、标准分配服务、价位段分配服务）
    - `importing`: 数据导入服务（Excel导入、业务校验）
    - `coordinator`: 协调型服务（区域客户统计构建、双周上浮、标签抽取、价位段候选查询、客户过滤分区清理）
    - `encode`: 编码服务（单区域编码、聚合编码懒加载）
    - `prediction`: 预测数据服务（查询、新增、删除、修改）
    - `writeback`: 分配结果写回服务（标准写回、价位段写回）
    - `adjust`: 策略调整服务（单卷烟策略调整）
    - `region`: 区域服务（获取可用投放区域）
    - `statistics`: 统计服务（投放组合区域映射、价位段订购量上限）
  - `coordinator/*`：包含算法服务配置、算法选择器、客户矩阵构建器、分组比例提供器等
  - `dto` / `converter`：在 API 与 Domain/Infrastructure 之间传递和转换数据。
  - `event.handler`：对领域/应用事件的响应处理（如导入完成、分配生成完成事件）。
- **可以做的事**：
  - 组合多个领域服务和仓储，完成完整的业务用例。
  - 处理事务边界（通过 `@Transactional` 注解）。
  - 调用 Infrastructure 层的实现（通过 Domain 的 Repository 接口）。
  - 处理错误恢复、重试、补偿等用例级逻辑。
  - 发布和监听领域事件（使用 Spring Event）。
- **不应该做的事**：
  - 自己实现核心业务规则或算法（应该放在 Domain 层）。
  - 直接写 SQL 或依赖底层技术细节（应通过 Repository / Mapper）。  

### 2.3 Domain 层（org.example.domain）

- **职责**：定义和实现业务领域的核心模型与规则，是系统的“业务大脑”和“单一算法真相源”。
- **包含内容**：
  - `model.entity`：领域实体（当前为预留目录，业务数据主要通过 Map/DTO 传递）。
  - `model.valueobject`：值对象（投放组合、投放方式类型、扩展投放类型等）。
  - `model.tag`：标签过滤规则接口。
  - `service.algorithm` / `service.rule` / `service.delivery`：领域服务与业务规则（包括分配算法、编码规则、标签过滤、全市占比、价位段、货源属性校验等）。
  - `repository`：仓储接口抽象。
  - `event`：领域事件。
- **可以做的事**：
  - 实现所有与业务强相关的计算、规则、约束（包括分配算法、编码规则、标签过滤等）。
  - 定义业务不变式（如字段必满足的关系、合法性校验）。
  - 定义对外暴露的领域 API（Service 接口）和数据抽象（Repository 接口）。
- **不应该做的事**：
  - 引入任何技术框架依赖（如 Spring、MyBatis、HTTP 客户端等）。
  - 直接访问数据库、缓存、消息中间件等基础设施。
  - 关心日志格式、监控上报细节（这类通常由 Application/Infrastructure 负责）。

### 2.4 Infrastructure 层（org.example.infrastructure）

- **职责**：为 Domain 与 Application 提供实际的技术实现，是“技术插件层”。
- **包含内容**：
  - `persistence.mapper` / `persistence.po`：MyBatis Mapper 与 PO（持久化对象支持继承，如 `CigaretteDistributionPredictionPricePO` 继承自 `CigaretteDistributionPredictionPO`，用于表结构相同但表名不同的场景）。
  - `repository.impl`：领域仓储接口的具体实现。
  - `algorithm` / `algorithm.impl`：历史版本最新算法实现（仅对比/回归使用）。
  - `config`：异步、编码规则、监控等配置。
  - `monitor`：事务/监控切面。
- **可以做的事**：
  - 实现 Repository 接口，编写 SQL、调用数据库。
  - 读写配置文件（如 `encoding-rules.yml`），将其提供给上层使用。
  - 实现监控、日志切面、技术性拦截等。
  - 保留历史算法实现，作为回归和差异对比的工具。
- **不应该做的事**：
  - 加入新的业务决策或业务规则（应下沉到 Domain）。
  - 反向依赖 Application 或 API 层。

### 2.5 Shared 层（org.example.shared）

- **职责**：为所有业务层提供**纯粹且通用**的基础能力，不包含具体业务流程和复杂规则。
- **包含内容**：
  - `constants`：业务/技术常量。
  - `exception`：统一异常处理入口。
  - `helper`：与导入/写入/表管理等相关的可复用辅助类。
  - `util`：通用工具方法。
  - `dto`：跨层共享的简单 DTO。
- **可以做的事**：
  - 提供无副作用或副作用简单可控的工具方法。
  - 为多层复用的结构提供统一定义（如 `RegionCustomerRecord`）。
- **不应该做的事**：
  - 写入复杂领域规则（如完整算法逻辑、标签规则等）。
  - 形成对某个特定业务用例有强依赖的代码（应放在 Application/Domain）。

---

## 三、内部依赖关系表（Who Depends on Whom）

本节用表格的方式，明确各层/模块之间“允许的依赖关系”和“禁止的依赖关系”，用于指导新增代码的落位与引用。

### 3.1 分层依赖矩阵（层级维度）

> 记法：✅ 允许依赖；❌ 禁止依赖。

| From \ To        | API 层        | Application 层 | Domain 层     | Infrastructure 层 | Shared 层     |
|------------------|--------------|----------------|---------------|-------------------|---------------|
| **API 层**       | –            | ✅              | ⭕（避免直接） | ❌                 | ✅             |
| **Application 层**| ❌           | –              | ✅             | ✅（经抽象/接口）  | ✅             |
| **Domain 层**    | ❌           | ❌             | –             | ❌                 | ✅             |
| **Infrastructure 层**| ❌       | ❌             | ✅（仅接口/抽象）| –                 | ✅             |
| **Shared 层**    | ❌           | ❌             | ❌             | ❌                 | –             |

- “⭕（避免直接）”：API 若直接依赖 Domain，容易把领域细节暴露给外部，一般建议通过 Application 转一道；  
  当前项目中主要遵循“API → Application → Domain”的调用路径。
- Infrastructure 可以依赖 Domain 的接口（如 Repository），但**绝不能**依赖 API/Application 具体实现。
- Shared 不依赖任何业务层，保持为所有层可复用的“工具箱”，也不反向引用上层。

### 3.2 典型模块间依赖关系示例

| 起点模块                              | 终点模块/接口                              | 依赖类型           | 说明                                                                                         |
|---------------------------------------|--------------------------------------------|--------------------|----------------------------------------------------------------------------------------------|
| `api.web.controller.*`                | `application.service.*` / `dto.*`          | 直接调用           | Controller 调用 Application Service，传入/返回 DTO/VO                                       |
| `DistributionCalculateController`     | `DistributionCalculateService`             | 直接调用           | 一键生成分配方案与汇总接口的唯一服务入口                                                    |
| `PredictionQueryController`           | `PredictionQueryService` / `AggregatedEncodingQueryService` | 直接调用 | 预测查询与聚合懒加载的应用服务入口                                                          |
| `application.service.*Impl`           | `domain.service.*`                         | 直接调用           | 应用服务编排多个领域服务完成用例                                                            |
| `DistributionAllocationOrchestrator`  | `DistributionStrategyManager` (`DefaultDistributionStrategyManager`) | 直接调用 | 通过 Facade 传入 `DistributionStrategyCommand`，由 Facade 统一完成校验与请求转换           |
| `DistributionAlgorithmEngine`         | `SingleLevelDistributionService` 等        | 直接调用           | 算法引擎只依赖 Domain 算法服务接口，不再依赖 Infrastructure 算法实现                         |
| `domain.repository.*`                 | （无，接口层）                             | 抽象定义           | 仅定义接口，由基础设施层实现                                                                |
| `infrastructure.repository.impl.*`    | `domain.repository.*`                      | 实现接口           | 通过 MyBatis Mapper/PO 实现领域仓储接口                                                     |
| `application.event.handler.*`         | `domain.event.*`                           | 事件监听/处理      | 应用层监听领域事件并做统计/监控等后置处理                                                   |

---

## 四、关键组件依赖关系表（Core Components Dependency）

本节从“单个业务链路”的角度，挑选几条主流程，列出关键类之间的调用关系，帮助新同学快速定位代码。

### 4.1 一键生成分配方案 & 写回链路

**场景**：运营在前端点击“一键生成分配方案”，系统根据预测数据与规则计算分配矩阵并写回预测表。

| 调用顺序 | 组件                                     | 所在层级         | 角色与职责简述                                                                                      |
|----------|------------------------------------------|------------------|-----------------------------------------------------------------------------------------------------|
| 1        | `DistributionCalculateController`       | API              | 接收 HTTP 请求（/api/calculate/generate-distribution-plan），记录日志，组装 Request VO             |
| 2        | `DistributionCalculateConverter`        | API              | 将 Request VO 转为 `GenerateDistributionPlanRequestDto`                                            |
| 3        | `DistributionCalculateService` / Impl   | Application      | 作为一键分配用例的应用服务入口，协调编排器、领域服务与仓储                                          |
| 4        | `DistributionAllocationOrchestrator`    | Application      | 组装业务语义的 `DistributionStrategyCommand`，调用 `DistributionStrategyManager` 触发策略执行     |
| 5        | `DistributionStrategyManager` / `DefaultDistributionStrategyManager` | Application (Facade) | 统一出口：在 Facade 内完成基础校验、默认值处理及 Command→`StrategyExecutionRequest` 的转换，并委托 `StrategyOrchestrator` 执行策略 |
| 6        | `StrategyOrchestrator`                  | Application      | 构建 `StrategyContext`，准备区域客户矩阵/目标量，调用 `DistributionAlgorithmEngine`                |
| 7        | `DistributionAlgorithmEngine`           | Application      | 决定使用哪一种领域算法服务（SingleLevel / ColumnWise / GroupSplitting），并执行算法                 |
| 8        | `AlgorithmServiceConfiguration`         | Application      | 通过 Spring Bean 配置将领域算法服务注册到容器，供 AlgorithmEngine 依赖注入使用                       |
| 9        | `SingleLevelDistributionService` 等     | Domain           | 领域层算法服务，执行核心分配算法逻辑                                                               |
| 10       | `CigaretteDistributionPredictionRepository` 等 | Domain    | 提供对预测/分配结果的读写抽象接口                                                                  |
| 11       | `*RepositoryImpl` + `*Mapper` + `*Po`   | Infrastructure   | 通过 MyBatis 将领域仓储操作落地到数据库                                                             |
| 12       | `DistributionWriteBackService`          | Application      | 将计算后的矩阵写回预测表，并做必要统计/记录（支持标准分配和价位段分配两种写回策略）                 |
| 13       | `GenerateDistributionPlanResponseDto/Vo`| Application / API| 组装返回结果 DTO/VO，并由 Controller 封装成统一响应返回前端                                         |

### 4.2 预测分区数据查询 & 价位段查询链路

**场景**：前端查询指定时间分区的预测数据或价位段预测数据，用于看板和校验。

| 调用顺序 | 组件                                  | 所在层级     | 角色与职责简述                                                                                     |
|----------|---------------------------------------|--------------|----------------------------------------------------------------------------------------------------|
| 1        | `PredictionQueryController`          | API          | 提供 `/api/prediction/list-by-time` 与 `/list-price-by-time` 查询接口                             |
| 2        | `PredictionQueryService` / Impl      | Application  | 封装预测数据/价位段数据查询的业务用例，对上屏蔽数据来源与表结构                                   |
| 3        | `CigaretteDistributionPredictionRepository` 等 | Domain | 提供查询预测分区或价位段数据的领域仓储抽象接口                                                    |
| 4        | `*RepositoryImpl` + `*Mapper` + `*Po`| Infrastructure | 通过 MyBatis 从相应预测表中查询数据                                                                |
| 5        | `PredictionQueryConverter`           | API          | 将 Mapper 返回的 `List<Map<String,Object>>` 等结构转为前端友好的 `PredictionQueryResponseVo`       |

### 4.3 聚合编码懒加载链路

**场景**：前端在查看预测分区数据列表时，按需（懒加载）查询某支卷烟在多区域聚合后的"编码表达式"。

| 调用顺序 | 组件                                      | 所在层级     | 角色与职责简述                                                                                         |
|----------|-------------------------------------------|--------------|--------------------------------------------------------------------------------------------------------|
| 1        | `PredictionQueryController.aggregatedEncodings` | API  | 接收 `/api/prediction/aggregated-encodings` 请求，解析 year/month/weekSeq/cigCode 参数                |
| 2        | `AggregatedEncodingQueryService` / Impl  | Application  | 按批次+卷烟代码懒加载聚合编码表达式，避免一次性加载全部区域数据                                       |
| 3        | `CigaretteDistributionPredictionRepository`     | Domain      | 提供按卷烟代码、时间批次查询预测记录的抽象接口                                                         |
| 4        | `CigaretteDistributionPredictionRepositoryImpl` + `CigaretteDistributionPredictionMapper` | Infrastructure | 通过 SQL 实现高效查询（如 `findByCigCode`），只返回该卷烟的相关记录                     |
| 5        | 领域规则/工具（如编码规则、表达式拼接）  | Domain / Shared | 按业务规则将多条记录聚合为一组"编码表达式"字符串列表                                                   |

### 4.4 区域客户统计构建链路

**场景**：系统根据投放组合信息，从 `customer_filter` 分区表中构建区域客户数统计，用于分配算法前置校验和统计报表。

| 调用顺序 | 组件                                     | 所在层级         | 角色与职责简述                                                                                      |
|----------|------------------------------------------|------------------|-----------------------------------------------------------------------------------------------------|
| 1        | `RegionCustomerStatisticsBuildService` / Impl | Application      | 作为区域客户统计构建的用例入口，扫描投放组合并协调构建流程                                          |
| 2        | `FilterCustomerTableRepository`          | Domain           | 提供对 `customer_filter` 分区表数据的抽象访问接口，包括分区数据插入、查询、统计等功能                |
| 3        | `FilterCustomerTableRepositoryImpl`     | Infrastructure   | 实现分区表操作，包括确保分区存在、插入数据、查询统计等                                              |
| 4        | `FilterCustomerTableMapper` + XML       | Infrastructure   | 通过 MyBatis 执行分区表相关的 SQL 操作                                                              |
| 5        | `RegionRecordBuilder`                   | Shared           | 根据投放组合策略构建区域客户数统计记录，调用 `FilterCustomerTableRepository` 查询分区数据            |
| 6        | `RegionCustomerStatisticsRepository`    | Domain           | 提供区域客户统计结果的持久化抽象接口                                                                |
| 7        | `RegionCustomerStatisticsRepositoryImpl` + Mapper | Infrastructure | 将构建的区域客户统计记录批量写入 `region_customer_statistics` 分区表                                 |

---

## 五、外部技术栈与依赖说明（External Dependencies）

本节从“技术组件”的角度，列出本项目主要使用的外部依赖，并说明它们大致用在什么地方、起什么作用，便于新同学快速建立整体印象。

### 5.1 核心框架与库

| 技术/依赖           | 主要作用                             | 在本项目中的典型使用位置/方式                                                   |
|---------------------|--------------------------------------|----------------------------------------------------------------------------------|
| Spring Boot         | 应用启动、自动配置、依赖管理         | `CigaretteDistributionApplication` 启动类；`@SpringBootApplication` 等注解      |
| Spring MVC          | REST 接口框架                        | `api.web.controller.*` 中的 `@RestController`、`@RequestMapping` 等             |
| Spring Validation   | 参数校验                             | Controller 请求 VO 上的 `@Valid`、字段约束注解                                  |
| Spring Event        | 应用/领域事件机制                    | `domain.event.*` 与 `application.event.handler.*` 之间的事件发布与监听         |
| Spring Context/DI   | 依赖注入与 Bean 管理                 | 全项目各层的 `@Component` / `@Service` / `@Autowired` / `@Bean` 等用法           |
| MyBatis             | ORM / SQL 映射                       | `infrastructure.persistence.mapper.*` + XML；`repository.impl.*` 调用 Mapper    |
| Lombok              | 消除样板代码                         | 实体/DTO/VO/服务上的 `@Data`、`@Getter`、`@Slf4j` 等注解                        |
| JUnit (Jupiter)     | 单元测试与集成测试                   | `src/test/java` 下的各类测试，尤其是 `GenerateDistributionPlanIntegrationTest`  |
| Micrometer / Metrics| 指标采集与监控                       | `MeterRegistryConfig` 等配置，结合 Spring Boot Actuator 使用                    |

### 5.2 配置与约定

| 配置/约定                      | 作用                                 | 说明                                                                             |
|--------------------------------|--------------------------------------|----------------------------------------------------------------------------------|
| `application.yml` / `application-*.yml` | Spring Boot 应用配置         | 包含数据源、端口、日志级别、MyBatis 配置等                                       |
| `config/encoding-rules.yml`    | 编码规则配置                         | 通过 `infrastructure.config.encoding` 加载，供 Domain 编码规则使用               |
| `config/import-validation-rules.yml` | 导入合法性校验配置          | 通过 `infrastructure.config.importing` 加载，为导入业务校验器提供全市占比及货源属性合法性规则 |
| MyBatis XML Mapper 文件        | SQL 配置与结果映射                   | 与 `*Mapper.java` 搭配定义具体 SQL 语句和结果映射关系                            |
| 日志配置（如 logback）         | 日志输出格式与级别控制               | 保证关键链路（如算法执行、导入校验）日志可追踪                                   |

---

## 六、架构约束与最佳实践（Constraints & Best Practices）

### 6.1 必须遵守的架构约束

- **约束 1：领域算法的“单一真相源”在 Domain 层**
  - 所有正式使用的分配算法（SingleLevel / ColumnWise / GroupSplitting）的权威实现，必须在 `domain.service.algorithm.*` 中。
  - `infrastructure.algorithm.*` 仅保留为“历史最新算法实现”，用于结果对比与回归验证，不允许被主业务链路直接依赖。

- **约束 2：Domain 不依赖 Infrastructure**
  - Domain 层只定义 `repository` 接口，由 Infrastructure 层实现；Domain 层代码不得引用 `infrastructure.*`。
  - 新增任何与数据库/缓存/外部系统有关的访问逻辑，必须经过 Repository 抽象，由 Infrastructure 具体落地。

- **约束 3：API 不直接触碰领域模型与仓储**
  - Controller 只能依赖 Application 层服务和 Shared 工具，禁止直接依赖 Domain 仓储或 Infrastructure Mapper。
  - 所有业务流程必须通过 Application 层组织，确保用例逻辑集中可读。

- **约束 4：Shared 保持无业务、不依赖业务层**
  - Shared 不得依赖 API/Application/Domain/Infrastructure 中的任何业务类。
  - 如某工具类开始包含明显的业务规则，应将其迁移到 Domain 或 Application。

### 6.2 推荐的开发实践

- **实践 1：先想“放在哪一层”，再写代码**
  - 写新功能前，先判断它是“用例编排”（Application）、“领域规则/算法”（Domain）、还是“技术实现”（Infrastructure），避免后期大搬家。

- **实践 2：所有对外接口都通过 DTO/VO 解耦**
  - API 层使用 VO，Application 层使用 DTO，Domain 层使用实体/值对象，避免直接向外暴露内部结构。

- **实践 3：新增主流程时优先补测试链路**
  - 参考 `GenerateDistributionPlanIntegrationTest`、`AggregatedEncodingQueryServiceIntegrationTest` 等写新的集成测试，保证链路可回归。

- **实践 4：运维观测点尽量集中在 Application 层**
  - 如本次重构将算法执行日志集中放入 `DistributionAlgorithmEngine`，避免在 Domain 算法内部散落过多日志。

- **实践 5：面向接口编程，优先依赖抽象**
  - Application 优先依赖 Domain 的 Service/Repository 接口，避免直接依赖具体实现类，方便未来替换与扩展。







