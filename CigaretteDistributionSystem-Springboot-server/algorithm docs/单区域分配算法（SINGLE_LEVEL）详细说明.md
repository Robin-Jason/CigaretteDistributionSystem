# 单区域分配算法（SINGLE_LEVEL）详细说明

## 一、算法概述

单区域分配算法（SINGLE_LEVEL）用于处理**单区域**的卷烟分配问题，通过"粗调 + 高档位微调"的两阶段策略，生成多个候选方案并选择误差最小的方案。

---

## 二、数学模型

### 2.1 问题定义

设共有 $B$ 个档位（通常 $B = 30$，从 D30 到 D1，索引从 0 到 29，其中索引 0 对应 D30，索引 29 对应 D1）。

对于档位 $j$（$j = 0, 1, \ldots, B-1$）：
- 令 $c_j$ 表示该档位的客户数（从给定的客户数表中获取）
- 令 $x_j$ 表示分配给档位 $j$ 的卷烟数量，其中 $x_j$ 为非负整数

### 2.2 约束条件

**单调性约束**（非递增约束）：
$$x_0 \geq x_1 \geq \cdots \geq x_{B-1}$$

即高档位分配值不小于低档位分配值（D30 ≥ D29 ≥ ... ≥ D1）。

**约束重要性**：单调性约束是第一位的，必须严格满足。如果某个操作违反约束，必须强制调整或跳过该操作。

### 2.3 目标函数

**实际投放量** $S$ 计算公式为：

$$S = \sum_{j=0}^{B-1} x_j \cdot c_j$$

**目标**：最小化误差 $|S - T|$，其中 $T$ 为预投放量。

---

## 三、算法详细步骤

### 3.1 阶段1：粗调阶段（候选方案1）

#### 3.1.1 算法描述

从最高档位（HG，索引 0）到最低档位（LG，索引 $B-1$），多轮逐档位 +1，直到刚好超出目标。

#### 3.1.2 具体步骤

1. **初始化**：
   
   - 将所有 $x_j$ 初始化为 0
   - 当前实际投放量 $S = 0$
   
2. **多轮填充**：
   
   ```python
   while True:
       hasProgress = False
       for j in range(0, B):  # 从HG到LG
           # 检查单调性约束
           if not isValidIncrement(x, j):
               continue
           
           # 计算+1后的新投放量
           newS = S + c_j
           
           # 如果恰好等于目标，直接返回
           if newS == T:
               x[j] += 1
               return x  # 候选方案1
           
           # 如果超出目标，停止
           if newS > T:
               return x  # 候选方案1（刚好超出前的状态）
           
           # +1操作
           x[j] += 1
           S = newS
           hasProgress = True
       
       # 如果一轮循环没有任何进展，退出
       if not hasProgress:
           break
   ```
   
3. **输出**：候选方案1（粗调结果）

#### 3.1.3 特殊情况处理

- **恰好等于目标**：如果粗调阶段恰好等于目标（$S = T$），直接返回候选方案1，**不生成其他候选方案**。
- **客户数为0的档位**：允许客户数为0的档位进行分配（+1操作），以保证单调性约束成立。虽然+1不会增加实际投放量，但可以保证约束条件成立。

---

### 3.2 阶段2：高档位微调阶段（候选方案2、3、4）

#### 3.2.1 候选方案2的生成

**步骤**：撤销粗调方案最后一次 +1 操作，作为候选方案2。

**具体实现**：
- 从低档位到高档位查找最后一次 +1 操作
- 撤销该操作，确保撤销后不超出目标
- 计算此时的余量：$\text{余量} = T - S_2$，其中 $S_2$ 为候选方案2的实际投放量

#### 3.2.2 迭代微调过程

基于候选方案2进行迭代微调，重复以下步骤直到满足终止条件：

**步骤a**：在候选方案2基础上，从HG开始逐档位 +1，直到刚好超出目标。

**步骤b**：撤销最后一次 +1 操作，更新候选方案2为此时方案，计算新余量。

**步骤c**：检查终止条件。

**终止条件**：某一轮开始HG+1前实际投放量 < 预投放量，+1后实际投放量 ≥ 预投放量。

即：
$$S_{\text{before}} < T \quad \text{且} \quad S_{\text{before}} + c_0 \geq T$$

其中 $S_{\text{before}}$ 为HG+1前的实际投放量，$c_0$ 为HG档位的客户数。

#### 3.2.3 候选方案3和4的生成

当满足终止条件时：

- **候选方案3**：HG+1前的方案（即当前候选方案2的状态）
  $$S_3 = S_{\text{before}}$$
  $$\text{误差}_3 = |S_3 - T|$$

- **候选方案4**：HG+1后的方案（如果HG可以+1且不违反单调性约束）
  $$S_4 = S_{\text{before}} + c_0$$
  $$\text{误差}_4 = |S_4 - T|$$

**注意**：如果HG+1违反单调性约束，则不生成候选方案4。

---

### 3.3 阶段3：方案选择

#### 3.3.1 误差计算

对于每个候选方案 $k$（$k = 1, 2, 3, 4$），计算误差：
$$\text{误差}_k = |S_k - T|$$

其中 $S_k$ 为候选方案 $k$ 的实际投放量。

#### 3.3.2 选择规则

1. **选择误差最小的方案**：
   $$\text{最优方案} = \arg\min_{k \in \{1,2,3,4\}} \text{误差}_k$$

2. **相同误差的处理**：如果多个候选方案的误差相同，选择编号更大的候选方案（候选方案4 > 3 > 2 > 1）。

#### 3.3.3 单调性约束强制执行

在最终返回前，**强制执行单调性约束**作为双重保险：

```python
# 对于每个档位，确保不违反单调性约束
for j in range(1, B):
    if x[j] > x[j-1]:
        x[j] = x[j-1]  # 强制调整
```

---

## 四、算法流程图

```
开始
  ↓
初始化：x_j = 0, S = 0
  ↓
【阶段1：粗调阶段】
  ↓
从HG到LG逐档位+1
  ├─ 检查单调性约束
  ├─ 如果恰好等于目标 → 返回候选方案1
  └─ 如果刚好超出目标 → 停止，得到候选方案1
  ↓
【阶段2：高档位微调阶段】
  ↓
撤销最后一次+1 → 候选方案2
  ↓
迭代微调（重复a、b步骤）
  ├─ a. 从HG开始逐档位+1，直到刚好超出
  ├─ b. 撤销最后一次+1 → 更新候选方案2
  └─ c. 检查终止条件（HG+1是否恰好超出）
  ↓
生成候选方案3（HG+1前）
生成候选方案4（HG+1后，如果可能）
  ↓
【阶段3：方案选择】
  ↓
计算4个候选方案的误差
  ↓
选择误差最小的方案
  ├─ 如果误差相同，选择编号更大的方案
  └─ 强制执行单调性约束
  ↓
返回最终方案
  ↓
结束
```

---

## 五、关键实现细节

### 5.1 单调性约束检查

**检查函数** `isValidIncrement(x, j)`：

```python
def isValidIncrement(x, j):
    """
    检查对档位j进行+1操作是否违反单调性约束
    
    参数:
        x: 分配方案数组
        j: 档位索引（0=HG, B-1=LG）
    
    返回:
        True: 不违反约束，可以+1
        False: 违反约束，不能+1
    """
    if j == 0:
        return True  # HG档位总是可以+1
    
    # 临时+1
    x[j] += 1
    
    # 检查是否违反约束（低档位不能大于高档位）
    if x[j] > x[j-1]:
        x[j] -= 1  # 恢复原值
        return False
    
    x[j] -= 1  # 恢复原值
    return True
```

### 5.2 撤销最后一次+1操作

**撤销函数** `rollbackLastIncrement(x, c, T, B)`：

```python
def rollbackLastIncrement(x, c, T, B):
    """
    撤销导致超出目标的最后一次+1操作
    
    参数:
        x: 当前分配方案
        c: 客户数数组
        T: 目标预投放量
        B: 档位数量
    
    返回:
        撤销后的分配方案
    """
    result = copy(x)
    
    # 从低档位到高档位查找最后一次+1操作
    for j in range(B-1, -1, -1):
        if result[j] > 0:
            # 尝试撤销这个+1
            result[j] -= 1
            newS = calculateAmount(result, c)
            
            if newS <= T:
                # 撤销后不超出，返回
                return result
            
            # 撤销后仍然超出，恢复并继续
            result[j] += 1
    
    return result
```

### 5.3 终止条件判断

**判断函数** `wouldExceedIfHighGradePlusOne(x, c, T)`：

```python
def wouldExceedIfHighGradePlusOne(x, c, T):
    """
    检查HG+1是否会超出目标
    
    参数:
        x: 当前分配方案
        c: 客户数数组
        T: 目标预投放量
    
    返回:
        True: HG+1会超出目标
        False: HG+1不会超出目标或HG不能+1
    """
    # 检查HG是否可以+1（单调性约束）
    if not isValidIncrement(x, 0):
        return False
    
    currentS = calculateAmount(x, c)
    newS = currentS + c[0]
    
    return newS >= T  # 是否超出或等于
```

---

## 六、算法复杂度分析

### 6.1 时间复杂度

- **粗调阶段**：$O(B \times R)$，其中 $B$ 为档位数量（通常为30），$R$ 为轮数（通常为1-3轮）
- **微调阶段**：$O(B \times I)$，其中 $I$ 为迭代次数（通常为1-5次）
- **方案选择**：$O(1)$，4个方案比较

**总时间复杂度**：$O(B)$，线性时间复杂度。

### 6.2 空间复杂度

- **分配方案存储**：$O(B)$
- **候选方案存储**：$O(4 \times B) = O(B)$

**总空间复杂度**：$O(B)$。

---

## 七、算法特点

### 7.1 优点

1. **误差最小化**：通过生成多个候选方案并选择误差最小的方案，确保结果最优
2. **单调性保证**：严格满足单调性约束，确保分配合理性
3. **高效性**：线性时间复杂度，适合实时计算
4. **鲁棒性**：处理边界情况（恰好等于目标、客户数为0等）

### 7.2 适用场景

- **单区域分配**：只有一个投放区域的情况
- **精确分配**：需要最小化误差的场景
- **实时计算**：需要快速响应的场景

---

## 八、示例

### 8.1 输入数据

- **档位数量**：$B = 30$
- **预投放量**：$T = 10000$
- **客户数数组**：$c = [100, 90, 80, \ldots, 10]$（30个档位）

### 8.2 执行过程

1. **粗调阶段**：
   - 从D30开始逐档位+1
   - 当实际投放量达到10050时，刚好超出目标
   - 候选方案1：实际投放量 = 10050，误差 = 50

2. **微调阶段**：
   - 撤销最后一次+1，得到候选方案2：实际投放量 = 9970，误差 = 30
   - 迭代微调，直到HG+1恰好超出
   - 候选方案3：实际投放量 = 9990，误差 = 10
   - 候选方案4：实际投放量 = 10090，误差 = 90

3. **方案选择**：
   - 候选方案3误差最小（10），选择候选方案3

### 8.3 输出结果

- **最终方案**：候选方案3
- **实际投放量**：9990
- **误差**：10
- **分配矩阵**：满足单调性约束的30个档位分配值

---

## 九、注意事项

1. **单调性约束**：约束条件重要性是第一位的，必须严格满足
2. **客户数为0的档位**：允许分配以保证约束成立
3. **恰好等于目标**：如果粗调阶段恰好等于目标，直接返回，不生成其他候选方案
4. **双重保险**：在最终返回前强制执行单调性约束，确保结果正确

---

**文档版本**：v1.0  
**最后更新**：2025年1月

